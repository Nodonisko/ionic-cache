import 'core-js';
import 'zone.js/dist/zone';
import 'zone.js/dist/long-stack-trace-zone';
import 'zone.js/dist/proxy';
import 'zone.js/dist/sync-test';
import 'zone.js/dist/jasmine-patch';
import 'zone.js/dist/async-test';
import 'zone.js/dist/fake-async-test';
import { CacheService, MESSAGES } from './cache.service';
import { TestBed } from '@angular/core/testing';
import {
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting
} from '@angular/platform-browser-dynamic/testing';
import { Storage } from '@ionic/storage';

import { of } from 'rxjs/observable/of';
import { _throw } from 'rxjs/observable/throw';
import { count } from 'rxjs/operators/count';

TestBed.initTestEnvironment(
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting()
);

describe('CacheService', () => {
  let service: CacheService;
  const ttl = 0.4;
  const key = 'https://github.com/Nodonisko/ionic-cache';
  const factoryKey = 'anotherKey';
  const groupKey = 'fooGroup';
  const cacheValue = 'ibby';
  const cacheFactoryValue = 100;

  beforeAll(async done => {
    service = new CacheService(
      new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      })
    );

    service.setOfflineInvalidate(false);

    await service.ready();
    done();
  });

  it('should create an instance of the service', () =>
    expect(service).toBeDefined());

  it('should save item to storage (async)', async done => {
    try {
      await service.saveItem(key, cacheValue, groupKey, ttl);
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should get previously stored value (async)', async done => {
    try {
      let value = await service.getItem(key);
      expect(value).toEqual(cacheValue);
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('previously stored value should exist in cache (async)', async done => {
    try {
      let value = await service.itemExists(key);
      expect(value).toBeTruthy();
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should save item generated by value factory to storage (async)', async done => {
    try {
      await service.getOrSetItem(factoryKey, () => Promise.resolve(10 * 10));

      let value = await service.getItem(factoryKey);
      expect(value).toEqual(cacheFactoryValue);
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should not execute value factory when key is in the cache (async)', async done => {
    let executed = false;

    await service.getOrSetItem(factoryKey, () => {
      executed = true;
      return Promise.resolve(20 * 20);
    });

    try {
      let value = await service.getItem(factoryKey);
      expect(value).toEqual(cacheFactoryValue);
      expect(executed).toBe(false);
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should throw error because cache expired (async)', done => {
    setTimeout(async () => {
      try {
        await service.getItem(key);

        expect(false).toBeTruthy();
        done();
      } catch (e) {
        expect(e).not.toBeUndefined();
        done();
      }
    }, ttl * 1000 + 1);
  });

  it('previously stored value should exist in cache even when value is expired (async)', async done => {
    try {
      let value = await service.itemExists(key);

      expect(value).toBeTruthy();
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should disable cache', () => {
    service.enableCache(false);
    expect((<any>service).cacheEnabled === false).toBeTruthy();
  });

  it('itemExist should reject because cache is disabled (async)', async done => {
    try {
      let value = await service.itemExists(key);
      expect(value).toBeUndefined();
      done();
    } catch (e) {
      expect(e).toEqual(new Error(MESSAGES[1]));
      done();
    }
  });

  it('should throw an error when getting item and cache is disabled', async done => {
    expect((<any>service).cacheEnabled === false).toBeTruthy();

    try {
      let res = await service.getItem(key);
      expect(res).toBeUndefined();
      done();
    } catch (e) {
      expect(e).toEqual(new Error(MESSAGES[1]));
      done();
    }
  });

  it('should enable cache', () => {
    service.enableCache(true);
    expect((<any>service).cacheEnabled === true).toBeTruthy();
  });

  it('itemExists should return false if item not exists', async done => {
    try {
      await service.clearAll();

      let res = await service.itemExists(key);
      expect(res).toBeFalsy();
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  afterAll(async done => {
    console.info('Clearing cache');

    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});

describe('Observable Caching', () => {
  const key: string = 'http_cache_test';

  let mockData: any = {
    hello: 'Hello world"s ',
    world: "It's beautiful day" // tslint:disable-line
  };

  let observable = of(mockData);

  let service: CacheService;

  beforeAll(async done => {
    service = new CacheService(
      new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      })
    );

    await service.ready();
    done();
  });

  beforeEach(() => {
    spyOn(observable, 'subscribe').and.callThrough();
  });

  it('should create an instance of the service', () => {
    expect(service).toBeDefined();
  });

  it('should return data from observable (async)', (done: any) => {
    service.loadFromObservable(key, observable).subscribe(
      res => {
        expect(res).toBeDefined();
        expect(observable.subscribe).toHaveBeenCalled();
        expect(res).toEqual(mockData);
        done();
      },
      err => {
        console.info('Error in observable', err);
        done(err);
      }
    );
  });

  it('should return cached observable data (async)', done => {
    service.loadFromObservable(key, observable).subscribe(res => {
      expect(observable.subscribe).not.toHaveBeenCalled();
      expect(res).toEqual(mockData);
      done();
    });
  });

  afterAll(async done => {
    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});

describe('Observable caching errors', () => {
  const key: string = 'http_cache_error_test';

  let mockData: any = {
    hello: 'Hello world"s ',
    world: "It's beautiful day" // tslint:disable-line
  };

  let observableError = _throw(mockData);

  let service: CacheService;

  beforeAll(async done => {
    service = new CacheService(
      new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      })
    );

    await service.ready();
    done();
  });

  beforeEach(() => {
    spyOn(observableError, 'subscribe').and.callThrough();
  });

  it('should create an instance of the service', () => {
    expect(service).toBeDefined();
  });

  it('should return data from observable (async)', (done: any) => {
    service.loadFromObservable(key, observableError).subscribe(
      res => {
        expect(true).toBeFalsy();
        done();
      },
      err => {
        expect(err).toBeDefined();
        done(err);
      }
    );
  });

  afterAll(async done => {
    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});

describe('Delayed observable caching', () => {
  const ttl = 1;
  const key = 'https://github.com/Nodonisko/ionic-cache';
  const groupKey = 'fooGroup';
  const mockData: any = {
    hello: 'Hello world'
  };
  const mockData2: any = {
    hello: 'Hello world again'
  };

  const observable = of(mockData);
  const observable2 = of(mockData2);

  let service: CacheService;

  beforeAll(async done => {
    service = new CacheService(
      new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      })
    );

    await service.ready();
    done();
  });

  beforeEach(() => {
    spyOn(observable, 'subscribe').and.callThrough();
    spyOn(observable2, 'subscribe').and.callThrough();
  });

  it('should create an instance of the service', () => {
    expect(service).toBeDefined();
  });

  it('should return data from observable (async)', (done: any) => {
    service.loadFromDelayedObservable(key, observable, groupKey, ttl).subscribe(
      res => {
        expect(res).toBeDefined();
        expect(observable.subscribe).toHaveBeenCalled();
        expect(res).toEqual(mockData);
        done();
      },
      err => {
        done(err);
      }
    );
  });

  it('should return cached observable data if is NOT expired (async)', done => {
    service
      .loadFromDelayedObservable(key, observable2, groupKey, ttl)
      .subscribe(res => {
        expect(observable2.subscribe).not.toHaveBeenCalled();
        expect(res).toEqual(mockData);
        done();
      });
  });

  it('should return 2 responses (cache, server) if is NOT exprired and delayType is all (async)', done => {
    service
      .loadFromDelayedObservable(key, observable2, groupKey, ttl, 'all')
      .pipe(count(() => true))
      .subscribe(
        count => {
          expect(observable2.subscribe).toHaveBeenCalled();
          expect(count).toEqual(2);
          done();
        },
        done,
        done
      );
  });

  it('should return 2 responses (cache, server) if is NOT exprired and delayType is all (async)', done => {
    service
      .loadFromDelayedObservable(key, observable2, groupKey, ttl, 'all')
      .subscribe(
        res => {
          expect(res).toEqual(mockData2);
          done();
        },
        done,
        done
      );
  });

  afterAll(async done => {
    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});

describe('Delayed observable caching error', () => {
  const ttl = 1;
  const key = 'https://github.com/Nodonisko/ionic-cache';
  const groupKey = 'fooGroup';
  const mockData: any = {
    hello: 'Hello world'
  };
  const mockData2: any = {
    hello: 'Hello world again'
  };

  const observable = of(mockData);
  const observable2 = of(mockData2);
  const observableError = _throw(mockData);

  let service: CacheService;

  beforeAll(async done => {
    service = new CacheService(
      new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      })
    );

    await service.ready();
    done();
  });

  beforeEach(() => {
    spyOn(observable, 'subscribe').and.callThrough();
    spyOn(observable2, 'subscribe').and.callThrough();
  });

  it('should create an instance of the service', () => {
    expect(service).toBeDefined();
  });

  it('should return error from observable (async)', (done: any) => {
    service
      .loadFromDelayedObservable(key, observableError, groupKey, ttl)
      .subscribe(
        res => {
          expect(true).toBeFalsy();
          done();
        },
        err => {
          expect(err).toBeDefined();
          expect(err).toEqual(mockData);
          done(err);
        },
        done
      );
  });

  it('should return data from observable (async)', (done: any) => {
    service.loadFromDelayedObservable(key, observable, groupKey, ttl).subscribe(
      res => {
        expect(res).toBeDefined();
        expect(observable.subscribe).toHaveBeenCalled();
        expect(res).toEqual(mockData);
        done();
      },
      err => {
        done(err);
      }
    );
  });

  it('should return one reponse and one error from observable (async)', (done: any) => {
    service
      .loadFromDelayedObservable(key, observableError, groupKey, ttl, 'all')
      .subscribe(
        res => {
          expect(res).toEqual(mockData);
        },
        err => {
          expect(err).toBeDefined();
          expect(err).toEqual(mockData);
          done(err);
        },
        done
      );
  });

  afterAll(async done => {
    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});
