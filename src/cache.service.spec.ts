import 'core-js';
import 'zone.js/dist/zone';
import 'zone.js/dist/long-stack-trace-zone';
import 'zone.js/dist/proxy';
import 'zone.js/dist/sync-test';
import 'zone.js/dist/jasmine-patch';
import 'zone.js/dist/async-test';
import 'zone.js/dist/fake-async-test';
import { CacheService, MESSAGES } from './cache.service';
import { TestBed } from '@angular/core/testing';
import {
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting
} from '@angular/platform-browser-dynamic/testing';
import { Storage } from '@ionic/storage';

import { of, throwError } from 'rxjs';
import { count } from 'rxjs/operators';
import { CacheStorageService } from './cache-storage';

function isPhantomJs() {
  return !!(<any>window)._phantom;
}

function getTtl() {
  return isPhantomJs() ? 5 : 2;
}

TestBed.initTestEnvironment(
  BrowserDynamicTestingModule,
  platformBrowserDynamicTesting()
);

describe('CacheService', () => {
  let service: CacheService;
  const ttl = getTtl();
  const key = 'https://github.com/Nodonisko/ionic-cache';
  const factoryKey = 'anotherKey';
  const groupKey = 'fooGroup';
  const cacheValue = 'ibby';
  const cacheFactoryValue = 100;
  let originalTimeout: number;

  beforeAll(async done => {
    service = new CacheService(
      new CacheStorageService(new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      }), 'ionic-cache-test')
    );

    service.setOfflineInvalidate(false);

    await service.ready();

    originalTimeout = jasmine.DEFAULT_TIMEOUT_INTERVAL;
    jasmine.DEFAULT_TIMEOUT_INTERVAL = ttl * 1000 * 2;

    done();
  });

  it('should create an instance of the service', () =>
    expect(service).toBeDefined());

  it('should save item to storage (async)', async done => {
    try {
      await service.saveItem(key, cacheValue, groupKey, ttl);
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should get previously stored value (async)', async done => {
    try {
      let value = await service.getItem(key);
      expect(value).toEqual(cacheValue);
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('previously stored value should exist in cache (async)', async done => {
    try {
      let value = await service.itemExists(key);
      expect(value).toBeTruthy();
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should save item generated by value factory to storage (async)', async done => {
    try {
      await service.getOrSetItem(factoryKey, () => Promise.resolve(cacheFactoryValue));

      let value = await service.getItem(factoryKey);
      expect(value).toEqual(cacheFactoryValue);
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should not execute value factory when key is in the cache (async)', async done => {
    let executed = false;

    await service.getOrSetItem(factoryKey, () => {
      executed = true;
      return Promise.resolve(cacheFactoryValue);
    });

    try {
      let value = await service.getItem(factoryKey);
      expect(value).toEqual(cacheFactoryValue);
      expect(executed).toBe(false);
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should throw error because cache expired (async)', done => {
    setTimeout(async () => {
      try {
        await service.getItem(key);

        expect(false).toBeTruthy();
        done();
      } catch (e) {
        expect(e).not.toBeUndefined();
        done();
      }
    }, ttl * 1000 + 1);
  });

  it('previously stored value should exist in cache even when value is expired (async)', async done => {
    try {
      let value = await service.itemExists(key);

      expect(value).toBeTruthy();
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('itemExist should reject because cache is disabled (async)', async done => {
    try {
      service.enableCache(false);

      let value = await service.itemExists(key);
      expect(value).toBeUndefined();
      done();
    } catch (e) {
      expect(e).toEqual(new Error(MESSAGES[1]));
      done();
    }
  });

  it('should throw an error when getting item and cache is disabled', async done => {
    try {
      service.enableCache(false);

      let res = await service.getItem(key);
      expect(res).toBeUndefined();
      done();
    } catch (e) {
      expect(e).toEqual(new Error(MESSAGES[1]));
      done();
    }
  });

  it('should enable cache', async done => {
    try {
      service.enableCache(true);

      await service.getOrSetItem(key, () => Promise.resolve(cacheFactoryValue));
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('itemExists should return false if item not exists', async done => {
    try {
      await service.clearAll();

      let res = await service.itemExists(key);
      expect(res).toBeFalsy();
      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  it('should work with multiple instances', async done => {
    try {
      await service.clearAll();

      await service.getOrSetItem(key, () => Promise.resolve(cacheFactoryValue));

      let secondService = new CacheService(
        new CacheStorageService(new Storage({
          name: '__ionicCache',
          driverOrder: ['indexeddb', 'sqlite', 'websql']
        }), 'ionic-cache-test')
      );

      let items = await secondService.getRawItems();
      expect(items.length).toEqual(1);

      done();
    } catch (e) {
      expect(e).toBeUndefined();
      done();
    }
  });

  afterAll(async done => {
    jasmine.DEFAULT_TIMEOUT_INTERVAL = originalTimeout;

    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});

describe('deleting items', () => {
  let service: CacheService;
  let storage: Storage;
  let storageKey = 'bob loblaw';
  let storageValue = 'lawblog';
  let cacheKey = 'banana stand';
  let cacheValue = 'always money';

  beforeAll(async done => {
    storage = new Storage({
      name: '__ionicCache',
      driverOrder: ['indexeddb', 'sqlite', 'websql']
    });

    service = new CacheService(
      new CacheStorageService(storage, 'ionic-cache-test')
    );

    await service.ready();
    done();
  });

  it('should only clear cache items', async () => {
    await storage.set(storageKey, storageValue);
    await service.saveItem(cacheKey, cacheValue);
    await service.clearAll();

    let keys = await storage.keys();
    expect(keys.length).toEqual(1);
    expect(keys[0]).toEqual(storageKey);
  });

  afterAll(async done => {
    try {
      await service.clearAll();
      await (<Storage>TestBed.get(Storage)).clear();
    } catch (e) {}

    done();
  });
});

describe('CacheService Deletion', () => {
  let service: CacheService;
  let cacheKey = 'banana stand';
  let cacheValue = 'always money';

  let wildcardItems = [
    ['movies/comedy/1', 'Scott Pilgrim vs. The World'],
    ['movies/comedy/2', 'The Princess Bride'],
    ['songs/metal/1', 'Who Bit the Moon'],
    ['songs/metal/2', 'Hail The Apocalypse'],
    ['songs/electronica/1', 'Power Glove'],
    ['songs/electronica/2', 'Centipede'],
  ];

  beforeEach(async done => {
    service = new CacheService(
      new CacheStorageService(new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      }), 'ionic-cache-test')
    );

    await service.ready();
    await service.clearAll();

    done();
  });

  it('should remove items', async () => {
    await service.saveItem(cacheKey, cacheValue);
    await service.removeItem(cacheKey);

    let keys = await service.getRawItems();
    expect(keys.length).toEqual(0);
  });

  it('should remove via wildcard (end)', async () => {
    await wildcardItems.reduce(async (promise, data) => {
      await promise;

      return service.saveItem(data[0], data[1]);
    }, Promise.resolve(true));

    await service.removeItems('movies/*');
    let keys = await service.getRawItems();
    expect(keys.length).toEqual(4);
  });

  it('should remove via wildcard (start)', async () => {
    await wildcardItems.reduce(async (promise, data) => {
      await promise;

      return service.saveItem(data[0], data[1]);
    }, Promise.resolve(true));

    await service.removeItems('*/1');
    let keys = await service.getRawItems();
    expect(keys.length).toEqual(3);
  });

  it('should remove via wildcard (book-ended)', async () => {
    await wildcardItems.reduce(async (promise, data) => {
      await promise;

      return service.saveItem(data[0], data[1]);
    }, Promise.resolve(true));

    await service.removeItems('*electronica*');
    let keys = await service.getRawItems();
    expect(keys.length).toEqual(4);
  });

  it('should remove via wildcard (middle)', async () => {
    await wildcardItems.reduce(async (promise, data) => {
      await promise;

      return service.saveItem(data[0], data[1]);
    }, Promise.resolve(true));

    await service.removeItems('s*1');
    let keys = await service.getRawItems();
    expect(keys.length).toEqual(4);
  });

  it('should remove via wildcard (complex)', async () => {
    await wildcardItems.reduce(async (promise, data) => {
      await promise;

      return service.saveItem(data[0], data[1]);
    }, Promise.resolve(true));

    await service.removeItems('songs*ctro*a/2');
    let keys = await service.getRawItems();
    expect(keys.length).toEqual(5);
  });

  afterAll(async done => {
    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});

describe('Observable Caching', () => {
  const key: string = 'http_cache_test';

  let mockData: any = {
    hello: 'Hello world"s ',
    world: "It's beautiful day" // tslint:disable-line
  };

  let observable = of(mockData);

  let service: CacheService;

  beforeAll(async done => {
    service = new CacheService(
      new CacheStorageService(new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      }), 'ionic-cache-test')
    );

    await service.ready();
    done();
  });

  beforeEach(() => {
    spyOn(observable, 'subscribe').and.callThrough();
  });

  it('should create an instance of the service', () => {
    expect(service).toBeDefined();
  });

  it('should return data from observable (async)', (done: any) => {
    service.loadFromObservable(key, observable).subscribe(
      res => {
        expect(res).toBeDefined();
        expect(observable.subscribe).toHaveBeenCalled();
        expect(res).toEqual(mockData);
        done();
      },
      err => {
        console.info('Error in observable', err);
        done(err);
      }
    );
  });

  it('should return cached observable data (async)', done => {
    service.loadFromObservable(key, observable).subscribe(res => {
      expect(observable.subscribe).not.toHaveBeenCalled();
      expect(res).toEqual(mockData);
      done();
    });
  });

  afterAll(async done => {
    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});

describe('Observable caching errors', () => {
  const key: string = 'http_cache_error_test';

  let mockData: any = {
    hello: 'Hello world"s ',
    world: "It's beautiful day" // tslint:disable-line
  };

  let observableError = throwError(mockData);

  let service: CacheService;

  beforeAll(async done => {
    service = new CacheService(
      new CacheStorageService(new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      }), 'ionic-cache-test')
    );

    await service.ready();
    done();
  });

  beforeEach(() => {
    spyOn(observableError, 'subscribe').and.callThrough();
  });

  it('should create an instance of the service', () => {
    expect(service).toBeDefined();
  });

  it('should return data from observable (async)', (done: any) => {
    service.loadFromObservable(key, observableError).subscribe(
      res => {
        expect(true).toBeFalsy();
        done();
      },
      err => {
        expect(err).toBeDefined();
        done(err);
      }
    );
  });

  afterAll(async done => {
    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});

describe('Delayed observable caching', () => {
  const ttl = getTtl();
  const key = 'https://github.com/Nodonisko/ionic-cache';
  const groupKey = 'fooGroup';
  const mockData: any = {
    hello: 'Hello world'
  };
  const mockData2: any = {
    hello: 'Hello world again'
  };

  const observable = of(mockData);
  const observable2 = of(mockData2);

  let service: CacheService;

  beforeAll(async done => {
    service = new CacheService(
      new CacheStorageService(new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      }), 'ionic-cache-test')
    );

    await service.ready();
    done();
  });

  beforeEach(() => {
    spyOn(observable, 'subscribe').and.callThrough();
    spyOn(observable2, 'subscribe').and.callThrough();
  });

  it('should create an instance of the service', () => {
    expect(service).toBeDefined();
  });

  it('should return data from observable (async)', (done: any) => {
    service.loadFromDelayedObservable(key, observable, groupKey, ttl).subscribe(
      res => {
        expect(res).toBeDefined();
        expect(observable.subscribe).toHaveBeenCalled();
        expect(res).toEqual(mockData);
        done();
      },
      err => {
        done(err);
      }
    );
  });

  it('should return cached observable data if is NOT expired (async)', done => {
    service
      .loadFromDelayedObservable(key, observable2, groupKey, ttl)
      .subscribe(res => {
        expect(observable2.subscribe).not.toHaveBeenCalled();
        expect(res).toEqual(mockData);
        done();
      });
  });

  it('should return 2 responses (cache, server) if is NOT exprired and delayType is all (async)', done => {
    service
      .loadFromDelayedObservable(key, observable2, groupKey, ttl, 'all')
      .pipe(count(() => true))
      .subscribe(
        count => {
          expect(observable2.subscribe).toHaveBeenCalled();
          expect(count).toEqual(2);
          done();
        },
        done,
        done
      );
  });

  it('should return 2 responses (cache, server) if is NOT expired and delayType is all (async)', done => {
    service
      .loadFromDelayedObservable(key, observable2, groupKey, ttl, 'all')
      .subscribe(
        res => {
          expect(res).toEqual(mockData2);
          done();
        },
        done,
        done
      );
  });

  afterAll(async done => {
    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});

describe('Delayed observable caching error', () => {
  const ttl = getTtl();
  const key = 'https://github.com/Nodonisko/ionic-cache';
  const groupKey = 'fooGroup';
  const mockData: any = {
    hello: 'Hello world'
  };
  const mockData2: any = {
    hello: 'Hello world again'
  };

  const observable = of(mockData);
  const observable2 = of(mockData2);
  const observableError = throwError(mockData);

  let service: CacheService;

  beforeAll(async done => {
    service = new CacheService(
      new CacheStorageService(new Storage({
        name: '__ionicCache',
        driverOrder: ['indexeddb', 'sqlite', 'websql']
      }), 'ionic-cache-test')
    );

    await service.ready();
    done();
  });

  beforeEach(() => {
    spyOn(observable, 'subscribe').and.callThrough();
    spyOn(observable2, 'subscribe').and.callThrough();
  });

  it('should create an instance of the service', () => {
    expect(service).toBeDefined();
  });

  it('should return error from observable (async)', (done: any) => {
    service
      .loadFromDelayedObservable(key, observableError, groupKey, ttl)
      .subscribe(
        res => {
          expect(true).toBeFalsy();
          done();
        },
        err => {
          expect(err).toBeDefined();
          expect(err).toEqual(mockData);
          done(err);
        },
        done
      );
  });

  it('should return data from observable (async)', (done: any) => {
    service.loadFromDelayedObservable(key, observable, groupKey, ttl).subscribe(
      res => {
        expect(res).toBeDefined();
        expect(observable.subscribe).toHaveBeenCalled();
        expect(res).toEqual(mockData);
        done();
      },
      err => {
        done(err);
      }
    );
  });

  it('should return one reponse and one error from observable (async)', (done: any) => {
    service
      .loadFromDelayedObservable(key, observableError, groupKey, ttl, 'all')
      .subscribe(
        res => {
          expect(res).toEqual(mockData);
        },
        err => {
          expect(err).toBeDefined();
          expect(err).toEqual(mockData);
          done(err);
        },
        done
      );
  });

  afterAll(async done => {
    try {
      await service.clearAll();
    } catch (e) {}

    done();
  });
});
